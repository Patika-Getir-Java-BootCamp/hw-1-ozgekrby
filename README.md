
## Why do we need to use OOP? Major OOP Languages?

Object-Oriented Programming (OOP) is an approach that makes software development much more organized, understandable, and sustainable. In large projects, as code complexity increases, managing the work can become challenging. OOP comes into play right here, becoming a structure used to overcome these difficulties. Especially in large projects, code needs to be modular, meaning divided into parts, for everything to work properly.

For example, an e-commerce platform has many different areas like product management, user management, payment processing. Thanks to OOP, we can create separate classes for each of these. Each class is organized to do its own job, which offers us a much cleaner and more readable code structure. Understanding what each class does becomes much easier.

Code reusability is a significant advantage in software development. Thanks to OOP's *inheritance* feature, one class can derive from another. For instance, when we create a `Product` class, subclassess like `Book` or `Electronics` deriving from this class can use common features without rewriting them. This both saves time and prevents unnecessary code repetition.

OOP's flexibility is also very important. Thanks to features like *abstraction* and *polymorphism*, adding new features is very easy. For example, if we initially build a system that only accepts credit card payments, adding new payment options like "PayPal" or "Bitcoin" later becomes much smoother with OOP. Without changing our code, we can easily integrate these features just by adding new classes.

On the maintenance side, thanks to the *encapsulation* feature, each object protects its own data and function. External interference becomes difficult, which increases the security of the software. If we need to change a component, this change does not affect other components, allowing us to update other parts of the system without breaking them.

Another major advantage of OOP is its ability to model real-world objects. We can program real-world objects in software more intuitively. For example, when we create a `user` object, it can have properties like name, surname, email, and perform actions like logging in and logging out. This makes the software both easier to understand and faster to develop.

OOP principles are applied in many popular programming languages. Languages like Java, C++, Python, C# strongly support OOP. For example, Java is a preferred language for large projects because it can run platform-independently. C++, on the other hand, is widely used in projects requiring performance, such as game engines or embedded systems.

In conclusion, OOP makes software development both more efficient and more sustainable. By making our code modular, we can manage it more easily, simplify maintenance, and prevent breaking the entire system when adding new features. If we are working on a large project, OOP is definitely a life-saving approach.

## Interface vs Abstract class?

*Interface* and *Abstract Class* might seem very similar in the OOP world, but actually, the situations where they are used are very different. Both ensure that classes adhere to a certain template, meaning they follow a certain structure, but how each is used depends on its purpose.

An *interface* is essentially a structure that shows which methods a class must implement. When a class *implements* a specific *interface*, it is forced to carry out all the methods contained within that *interface*. But it is important to note here that the *interface* only specifies the names and parameters of the methods, it does not contain the operation of the methods. For example, let's say we have an *interface* called `Payment` in an e-commerce platform. Let this *interface* have a method named `processPayment`. Every class that *implements* this method, i.e., classes representing different payment methods such as credit card, PayPal, or bank transfer, must implement the `processPayment` method according to their own operations. However, the *interface* only specifies what kind of functionality this method should have; the content of the payment method can be different in each class.

An *abstract class* is a class that carries both abstract and concrete features. That is, some methods are only defined, meaning their signature is created, and subclasses must *implement* these methods, but some methods can also be fully defined. For example, we have an `Order` *abstract class*. This class may contain a `processOrder` method, and this method may have a general *implementation*. However, since a method like `calculateShipping` needs to be calculated differently for each e-commerce site, each subclass, i.e., the `PhysicalProductOrder` or `DigitalProductOrder` class, will have to *implement* this method according to its own logic. Here, the *abstract class* writes the common functionality once and allows some methods to be customized in subclasses.

If multiple classes need to *implement* the same methods, it would be more appropriate to use an *interface*. For example, in an e-commerce platform, the `Shipping` process, with the `calculateShipping` method, can be located in different classes. Each class can use its own special shipping calculation algorithm. However, if we want to share basic functionality, an *abstract class* would be more logical. So, if you have a base class like `Order`, some methods of this class can be both general and common. The general functionality of a method like `processOrder` is already the same for all orders, but a method like `calculateShipping` needs to be left to the subclasses.

There are also other differences. *Interfaces* are *implemented* by classes using the `implements` keyword, while *Abstract Classes* are extended by subclasses using the `extends` keyword. An *Interface* can do multiple *implementation*, while an *Abstract Class* can only be extended by a single class.

In summary, an *interface* allows different classes to share the same type of behaviors, but each class defines its own operation. An *abstract class*, on the other hand, provides common functionality, but requires each subclass to *implement* some methods. Which structure we use depends on the needs of our application. If we are going to have classes with many different behaviors, it is correct to use an *interface*. However, if we want to provide a more limited inheritance structure and common functionality, using an *abstract class* is the most logical.

## Why do we need equals and hashcode? When to override?

Every object in Java automatically inherits from the `Object` class, so it inherently has `equals()` and `hashCode()` methods by default. However, the default states of these methods usually do not fully meet our needs. The `equals()` method is used to check if two objects are equal. Java's default `equals()` method determines equality by comparing the memory addresses of objects. That is, two objects are considered "equal" only if they are stored at the same address. However, in the real world, it is often more important whether objects are logically equal. The `hashCode()` method, on the other hand, returns the *hash code* of an object. This *hash code* determines how the object will be stored and found within a collection. Structures like `HashMap`, `HashSet` in particular work by looking at the `hashCode()` method when managing objects.

For example, in an e-commerce site, each product has a unique product code. There cannot be two products with the same product code. Therefore, when we compare products, we should compare them according to their product codes, not where they are stored in memory. If we do not *override* the `equals()` method, Java will compare products according to their memory addresses. That is, even two products with the same product code will not be considered equal if they are stored in different places in memory.

We have a list of products in your e-commerce platform and we are trying to add a product with the same product code twice. If we do not *override* the `equals()` method, Java will see these two products as different objects, and two products with the same product code may be in the list. To prevent this, we must *override* the `equals()` method in a logical way so that Java compares products only by product code. Along with this, we must also *override* the `hashCode()` method because Java performs operations according to *hash codes* when storing objects in collections such as `HashMap`, `HashSet`. If we *override* the `equals()` method and do not change the `hashCode()` method, Java may give different *hash codes* to two products with the same product code. In this case, a product with the same product code can be added to the `HashSet` twice because `HashSet` determines whether the added object will be added to the collection by first looking at the `hashCode()` method and then at the `equals()` method. If the *hash codes* are different, `HashSet` sees them as different objects. Therefore, if we are changing the `equals()` method, we must also change the `hashCode()` method. In addition to this, if two objects are equal according to the `equals()` method, their `hashCode()` methods must also return the same result.

When comparing the logical equality of products on an e-commerce platform, we must *override* the `equals()` method. For example, if each of our products has a unique identifier (e.g., product code, SKU number), we should use the `equals()` method to compare these identifiers. If we are storing our products in a `HashMap`, `HashSet`, or `HashTable`, we should also *override* the `hashCode()` method. Also, when we *override* the `equals()` method, we must also *override* the `hashCode()` method.

In conclusion, the `equals()` method determines whether two objects are equal. By default, it compares memory addresses, but we can change this. The `hashCode()` method determines how the object will be stored in collections. If we *override* the `equals()` method, we must also *override* the `hashCode()` method, and the *hash codes* of equal objects must be the same. Therefore, *overriding* `equals()` and `hashCode()` in Java is extremely important for writing correct and error-free code.

## Diamond Problem in Java? How to fix it?

The *Diamond Problem* is a problem caused by multiple inheritance in Java. Java does not directly support multiple inheritance between classes because this situation can lead to the compiler being indecisive about which method to call. This problem arises especially when a class needs to inherit from more than one superclass.

For example, let's say we have a class named `Product`. This class contains basic information about the product. We also have two subclasses, `DigitalProduct` and `PhysicalProduct`. The `DigitalProduct` class carries some features related to digital products, while the `PhysicalProduct` class contains information related to physical products.

Now, let's say we have a class named `Order` and we think that this class should inherit from both `DigitalProduct` and `PhysicalProduct` classes in order to process both digital and physical products. However, a situation to be noted here is that both classes derive from the `Product` class, and there is a method (e.g., `getPrice()`) in the `Product` class. If the `Order` class tries to derive from both `DigitalProduct` and `PhysicalProduct` classes, the `Order` class inherits the `getPrice()` method from both classes. But here, an ambiguity arises, which `getPrice()` method will the `Order` class use? This ambiguity is called the *Diamond Problem*.

To prevent this problem, Java only supports *multiple inheritance* through *interfaces*. That is, a class can *implement* multiple *interfaces*, but cannot inherit from multiple classes. If a situation arises where the same method is defined in different *interfaces*, the Java compiler cannot know which method to call and the code will give an error.

There are two basic approaches to solve this problem:

Using *Interface*s: In Java, a class can *implement* multiple *interfaces*. For example, instead of inheriting the `Product` class, the `DigitalProduct` and `PhysicalProduct` classes can *implement* *interfaces* such as `ProductDetails` and `ProductShipping`. Thus, the `Order` class can *implement* both *interfaces*, and operations can be performed through the methods defined in these *interfaces*.

Using *Composition*: Using *composition* instead of inheritance is also a solution. That is, instead of inheriting the `DigitalProduct` and `PhysicalProduct` classes, the `Order` class can contain them as objects. This approach makes the relationships between classes more flexible and eliminates ambiguities such as the *Diamond Problem*. For example, the `Order` class can contain both `DigitalProduct` and `PhysicalProduct` classes as properties and perform the operation by calling the `getPrice()` method of each separately.

In conclusion, the *Diamond Problem* is an ambiguity problem caused by multiple inheritance in Java. To prevent this problem, Java has prohibited multiple inheritance in classes, but has offered a solution through *interfaces*. If the same method exists in more than one *interface* and these are *implemented* in the same class, it should be *overridden* and it should be clearly determined which method will be called. Alternatively, the *composition* method can also be used to ensure that a class contains other classes as objects instead of inheriting them.

## Why do we need Garbage Collector? How does it run?

*Garbage Collector* is a mechanism used in languages that provide automatic memory management, such as Java, to prevent programmers from manually dealing with memory allocation and cleanup operations. In Java, memory management is performed automatically, and the *Garbage Collector* optimizes memory by cleaning up objects that are no longer in use.

Let's explain with an e-commerce example: Consider an online store system. When a customer adds products to their cart, each product is created as an object in memory. If the customer leaves the page without completing the purchase, the object of the products in their cart becomes unused. If these objects are not cleaned up manually, they take up unnecessary space in memory, and *memory leaks* may occur over time. This is where the *Garbage Collector* comes into play. It detects unused objects and cleans them from memory.

To understand how the *Garbage Collector* works, we need to know how it works. The *Garbage Collector* in Java works with the *Mark and Sweep* algorithm. First, the *Garbage Collector* marks all objects that are accessible from *root* reference points. That is, if an object still has an active reference, it is considered "live". Then, unmarked objects, i.e., objects with no references, are cleaned and memory is reclaimed.

In Java, the *Garbage Collector* is managed by the JVM (*Java Virtual Machine*) and cannot be called manually by the programmer. However, it can be requested to be run with the `System.gc();` or `Runtime.getRuntime().gc();` methods. Nevertheless, the JVM decides when the *Garbage Collector* will run, and this process should not affect the performance of the program.

To make memory management more efficient, the *Garbage Collector* uses different memory regions. These regions are divided into *Young Generation*, *Old Generation*, and *Permanent Generation*. New objects are initially placed in the *Young Generation* region. Over time, these objects are moved to the *Survivor* area and, as their lifespan increases, they move to the *Old Generation*. These object movements to regions determine when the *Garbage Collector* should clean up objects.

For example, when a product is added to the cart, this product is placed in the *Young Generation* region. If the customer keeps this product in their cart and buys it after a few operations, the product is moved to the *Old Generation*. However, if the product cart is emptied and this product is no longer used, the *Garbage Collector* detects this object and cleans it up.

In conclusion, the *Garbage Collector* automates memory management, eliminating the need for manual memory management and allowing the program to run more stably and efficiently. However, the *Garbage Collector* is not completely controllable and should be used carefully in terms of performance. Because large and frequent cleanup operations can stop the program and create a "*stop-the-world*" effect. This may cause the program to pause for a short time. Therefore, to optimize the behavior of the *Garbage Collector*, it is important to choose the correct JVM *tuning* and *garbage collection* algorithms (such as G1, CMS, Parallel GC).

## Java 'static' keyword usage?

In Java, the `static` keyword is used to make a member (variable, method, block) belonging to a class belong to the class itself. This allows members to be accessible at the class level without creating an object. That is, it is used to create a member that is valid for the class itself, not for each object of a class. For example, let's assume that there is a campaign code valid for all users on an e-commerce platform. In this case, the campaign code should be common to all users, not separate for each user. This is where the `static` keyword comes into play. A `static` variable defined within a class is a variable shared by all objects of the class. That is, each instance of the class carries the same value for this `static` variable. In the e-commerce example, since a campaign code is the same for all users, this campaign code can be defined as a `static` variable. In this way, a separate value is not kept for each user object, and memory is saved. *Static* methods can be called directly with the class name without creating an instance of a class. *Static* methods can only work with *static* members and cannot directly use any object-owned variables or methods. In an e-commerce platform, *static* methods can be used for operations that are not object-dependent, such as payment processing, because such operations are generally valid for the entire class without requiring object-specific information. *Static* blocks are special code blocks that are executed first when a class is loaded. These blocks are generally used to assign initial values to *static* variables. In e-commerce systems, it may be common to use a *static* block that performs such operations in cases where payment gateways or external service connections are configured. These blocks are executed only once and automatically come into play when the class is loaded for the first time. *Static* inner classes are classes that can be used independently of the instance of the outer class. *Static* inner classes can be used for classes that do not directly interact with the outer class and only function as a structural helper element of the class. In this way, the functionality of the inner class can be utilized without having to create an instance of the outer class.

*Static* variables optimize memory usage because they are shared by all instances of the class. For example, when a counter variable is defined as *static*, this counter increases every time an object is created and shows the same value for all objects. *Static* methods are generally used as *utility* methods. For example, they are ideal for non-object-specific operations such as mathematical operations, string manipulations, or date operations. The `Math` class in Java is one of the best examples of *static* methods. *Static* blocks are executed once when the class is loaded and are generally used for initial configurations or resource loading. For example, a database connection or a file reading operation can be performed in a *static* block. *Static* inner classes work more independently because they are not dependent on the instance of the outer class. This is ideal especially for helper classes that do not need the state of the outer class. For example, an `OuterClass.InnerClass` structure can be used directly without the need for an instance of the outer class. There are also disadvantages to *static* usage. It should be used carefully, especially in *multi-threading* environments. *Static* variables can cause synchronization problems because they are shared by all threads. Also, *static* methods and variables can be difficult to test because it is difficult to abstract dependencies.

In conclusion, the `static` keyword is used in Java to define members at the class level and to create shared resources among these members. *Static* variables and methods provide significant advantages in terms of memory management and add class-level functionality in object-oriented programming. This keyword is generally preferred for global functionality and shared data. However, care should be taken when using *static*, and precautions should be taken against synchronization problems, especially in *multi-threading* environments.

## Immutability means? Where, How and Why to use it?

*Immutability* refers to the state of an object being unchangeable after it is created. That is, once the values of an object are determined, no changes are made to that object. In Java, *immutability* is generally preferred to increase security, reduce errors, and write more reliable code. In e-commerce systems, for example, when a payment transaction is made, the payment information should be *immutable*. In this way, data modification is prevented during the payment process and security is increased. There are some important rules to ensure *immutability*. First, the class itself must be `final`, thus preventing the class from being extended by subclasses. Subclasses can change the content of a class, which contradicts the principle of *immutability*. Secondly, all variables in the class must be `final` and `private`. `Final` variables can only be assigned once and cannot be changed later. Being `private` restricts external access, so they can only be manipulated by the code within the class. Third, *immutable* classes should not have *setter* methods because *setter* methods can change the internal state of the object. This is contrary to the principle of *immutability*. Fourth, initial values are assigned to the object with the *constructor* (constructor method), and these values cannot be changed later. In *immutable* classes, other objects within it must also be *immutable* or copied correctly. If objects refer to other objects, these references must be copied before being given externally. Thus, external codes cannot change the data of the object.

*Immutable* objects are particularly useful in *multithreading* applications. Because *immutable* objects cannot be changed by one thread, which allows other threads to work safely with the same object. In applications such as e-commerce, for example, customer data can be stored as *immutable*, so different threads can safely process the same data. *Immutable* objects are also ideal for data that should not be changed from the outside. Data that should not change, such as financial transactions or date information, can be stored with *immutable* objects, which ensures data integrity. *Immutability* also increases maintainability and testability because once an object is created and does not change, the state of this object is fixed during tests or when examining the code. This helps reduce errors and develop more reliable software.

*Immutability* provides great advantages in software development, especially in terms of security and performance. For example, the `String` class in Java is one of the best-known examples of *immutability*. A `String` object cannot be changed after it is created, which allows `String` objects to be shared securely. Also, *immutable* objects improve performance, especially in large data structures and distributed systems. Because these objects do not change, they can be safely used by multiple threads or systems. *Immutability* is also one of the cornerstones of the functional programming paradigm. In functional programming, instead of changing data, new data is created, which makes the code more understandable and more resistant to making mistakes. *Immutable* objects are also used, especially in *cache* mechanisms. For example, if the data stored in a *cache* does not change, the consistency of the *cache* is maintained and the risk of returning incorrect data is reduced. *Immutability* also facilitates the use of objects in *hash* tables. Because the *hash code* of an object remains constant as long as the content of the object does not change, which ensures the correct operation of *hash* tables.

In conclusion, *immutability* is a design principle in software development that increases security, reduces errors, and makes code more understandable. In systems such as e-commerce, in *multithreading* environments, in secure data structures, and in situations where data that should not change is needed, using *immutable* objects is very beneficial. *Immutability* offers great advantages, especially in terms of security, performance, and code sustainability, and is an indispensable concept in modern software development processes.

## Composition and Aggregation means and differences?

*Composition* and *Aggregation* define component relationships in object-oriented programming (OOP) and express the relationship and dependency levels between objects in different ways. *Composition* expresses a relationship in which an object is completely dependent on another object. That is, an object controls the life cycle of the other objects it contains, and these objects also disappear when the object they are connected to disappears. This relationship implies strong ownership, and the life of the "composite object" depends on the life of the owning object. *Composition* is generally used in situations where an object is "owned" or "part of" another object. For example, a `Car` class may contain a `Motor` class. If the car disappears, the engine also disappears because the engine is an integral part of the car. As another example, inside a `House` object, there may be `Rooms` objects belonging to it. If the house disappears, the rooms also disappear because the rooms are part of the house and do not have an independent life of their own. In this case, the relationship between the house and the rooms is *composition*.

*Aggregation*, on the other hand, is a weaker relationship. In this case, an object may be connected to another, but their life cycles are independent of each other. That is, an object may own or be connected to another object, but this is independent, and even if one object disappears, the other object can survive. *Aggregation* generally expresses situations where "parts" are more loosely related to "wholes". This can be thought of as a less powerful ownership relationship. For example, a `University` class may have a `Department` class. However, even if the university closes, the departments can continue to exist independently. Another example might be the relationship between `Student` and `Course`. A student may be enrolled in multiple courses, but even if a student leaves a course, the course can continue and other students can also participate. The relationship here is *aggregation* because the life of the course does not depend on the life of the student.

The differences between *Composition* and *Aggregation* are as follows: *Composition* expresses a stronger relationship than *aggregation*. In *Composition*, component objects are completely dependent on the owning object, while in *aggregation*, objects are independent. In terms of lifecycle, in *Composition*, the objects inside disappear when the owning object disappears, while in *Aggregation*, even if one object disappears, the other object can survive. Ownership is strong in *Composition* and the object owns the other, while ownership is weaker in *Aggregation* and objects are independent of each other.

*Composition* and *Aggregation* are important concepts in object-oriented design, and when used correctly, they increase the flexibility and sustainability of the software. *Composition* is especially used in situations where an object is closely linked to other objects. For example, considering a computer system, components such as the motherboard, processor, and memory inside the computer lose their meaning when the computer disappears. Therefore, *composition* is preferred in such relationships. *Aggregation* is more suitable for looser relationships. For example, the relationship between a shopping cart and products can be modeled as *aggregation*. Even if the cart disappears, the products can continue to exist. In addition, *aggregation* is also used in situations where objects can be associated with multiple wholes. For example, a teacher can teach in multiple classes, and these classes can continue to exist even if the teacher disappears. *Aggregation* is more appropriate in such scenarios.

Another important difference between *Composition* and *Aggregation* is related to the flexibility of the design. *Composition* offers a more rigid structure, and the dependency between objects is high. While this may be advantageous in some cases, it may limit the reusability of objects. *Aggregation*, on the other hand, offers a more flexible structure and allows objects to be used independently. This increases the reusability of objects, especially in large and complex systems. For example, a student object can be enrolled in multiple courses, and these courses can be managed independently. *Aggregation* is more appropriate in such scenarios.

In conclusion, *composition* and *aggregation* manage the relationship between objects in different ways. *Composition* expresses a strong and tight relationship because the life cycles of objects are linked to each other. *Aggregation*, on the other hand, defines a looser relationship, objects have independent life cycles, and even if an object is connected to another, they can continue to exist. These differences are important for choosing the correct relationship in software design. *Composition* is used especially when an object is closely linked to other objects, while *aggregation* is preferred for more flexible and independent relationships. Both concepts are critical for making correct design decisions in object-oriented programming.

## Cohesion and Coupling means and differences?

*Cohesion* and *Coupling* are two fundamental concepts used in software design and are related to how a class or module should be organized. These concepts can directly affect the quality, sustainability, and flexibility of software. *Cohesion* expresses how "focused" a class or module is, that is, how related the components within it are to each other. High *cohesion* means that a class or module focuses on a specific task and contains all the functionality related to this task. High *cohesion* generally provides a more readable, easy-to-maintain, and error-free software design. For example, if a `Library` class only contains operations related to books, this class is said to have high *cohesion* because all functions are focused on the responsibility of the library. However, in a low *cohesion* situation, if a class performs very different functions, for example, managing both book management and financial transactions, *cohesion* decreases and software maintenance becomes difficult.

*Coupling*, on the other hand, expresses the dependency of a class or module on another class or module. Low *coupling* shows how independent a class or module is from another class or module. Low *coupling* increases the flexibility and sustainability of the software by reducing the dependency between modules. With low *coupling*, changing one module does not affect others, and software maintenance becomes easier. For example, if a `Library` class only performs operations related to books and is independent of other modules, we can talk about low *coupling*. However, in a high *coupling* situation, modules are tightly linked to each other. For example, if a `Library` class is dependent on the functions of other modules, such as both book management and payment processing, we are talking about high *coupling*. In this case, changes made to one module may affect other modules, and software maintenance becomes difficult.

*Cohesion* shows how related the elements within a class or module are, while *Coupling* shows how dependent that class or module is on other modules. High *cohesion* means that a class carries only one responsibility and contains the functionalities related to this responsibility, while low *coupling* means that the class should be as independent as possible from other classes or modules. *Cohesion* generally evaluates the quality of the internal structure of the class or module, while *Coupling* evaluates the quality of the external relationships between modules.

*Cohesion* and *Coupling* are two important principles that complement each other in software design. High *cohesion* ensures that a class or module focuses on a single responsibility. This is also consistent with the *Single Responsibility Principle* (SRP). SRP states that a class should only have one reason to change. For example, a `User` class should only manage user information and should not take on other responsibilities such as payment processing. This makes the class more understandable and testable. Low *coupling*, on the other hand, makes the software more flexible by reducing the dependency between modules. This is also consistent with the *Dependency Inversion Principle* (DIP). DIP suggests that high-level modules should not be dependent on low-level modules, and both should be dependent on abstractions. For example, a module that performs a payment operation should not be directly dependent on payment methods (credit card, PayPal, etc.), but should be dependent on a payment *interface* instead. This does not require changing the existing code when adding new payment methods.

*Cohesion* and *Coupling* become even more important, especially in large and complex systems. High *cohesion* allows modules to be divided into smaller and more manageable parts. This allows different developers to work independently of each other in team work. Low *coupling*, on the other hand, makes it easier to develop and test modules independently of each other. For example, in an e-commerce system, modules such as product management, payment processing, and user management can be developed independently of each other. This ensures that a change made in one module does not affect other modules.

In conclusion, both high *cohesion* and low *coupling* are ideal situations in software design. High *cohesion* helps to create a cleaner and more understandable structure by focusing modules on their purpose, while low *coupling* increases the flexibility and maintainability of the software by reducing the dependency between modules. These two principles ensure that the software is more sustainable and manageable in the long run. High *cohesion* and low *coupling* are indispensable concepts in modern software development processes and significantly improve the quality of the software when applied correctly.

## Heap and Stack means and differences?

*Heap* and *Stack* are two different data structures used for memory management in computer science. Both *Heap* and *Stack* are used to store data, but their functions and how they work are quite different. Understanding these two structures makes a significant difference in memory management and software development process. Now let's examine both in more detail and look at the differences between them.

*Stack* is a type of "stack" data structure and in a very basic way, it is a structure where data is added and removed sequentially. It is based on the LIFO (*Last In, First Out*) principle. That is, the last data added is the first to be removed. *Stack* is especially used for managing function calls and local variables. Each time a function is called, the data belonging to that function is added to the *stack* as the function's workspace (*stack frame*). When the function ends, the data of that function is removed from the *stack*. *Stack* is generally fast because adding and removing data are simple operations. However, the size of the *stack* is limited, and adding too much data can lead to a *stack overflow* error.

For example, when a function is called, the function's local variables, return address, and other related data are added to the *stack*. When the function is completed, this data is removed from the *stack* and returns to the previous function call. This process is very fast because the operating principle of the *stack* is quite simple.

*Heap* is a more dynamic and flexible memory area. Unlike *Stack*, *Heap* is a free memory area, and the data storage operation here is more complex. In *Heap*, data is not added and removed in a specific order. Instead, the memory needed by the program is dynamically allocated. *Heap* is generally used in dynamic memory management and object-oriented programming. For example, in languages like Java, an object is created on the *heap* with the `new` keyword. Data in the *heap* may remain until the relevant memory area is released. Therefore, *heap* is managed by mechanisms such as *garbage collection*, and its management is more complex than *stack*.

*Heap* is used for larger data structures and dynamic memory. However, adding and removing data in *heap* may be slower than *stack* because memory is dynamically allocated and released. Also, data in the *heap* is managed by the *garbage collector*, meaning there may be risks of *memory leaks* and unnecessary data accumulation.

Differences:

Data Management: *Stack* works according to the LIFO principle, i.e., the last data added is the first to be removed. In *Heap*, data is managed dynamically and can be released. In *Stack*, each data is related to function calls and is processed sequentially. *Heap*, on the other hand, is a freer area and is especially used for dynamic object management.

Memory Allocation: *Stack* allocates memory of a fixed size and is generally fast. *Heap*, on the other hand, can allocate larger memory blocks and can grow dynamically, but memory management is more complex.

Memory Management: *Stack* holds temporary data between functions, while *heap* is used for long-term data storage. Data in the *heap* can remain in the memory area for a longer period and is managed by *garbage collection*.

Performance: *Stack* is very fast because data is only added and removed. In *Heap*, memory allocation and release operations are slower and require more processing.

Memory Leaks: In *Stack*, memory is automatically released. However, in *heap*, releasing memory is left to the programmer, and it can lead to memory leaks if managed incorrectly.

*Stack* and *Heap* are the cornerstones of memory management in programming languages. *Stack* is used especially for function calls and local variables, while *Heap* is used for larger and dynamic data structures. The size of the *stack* is usually limited, and therefore adding too much data can cause a *stack overflow* error. *Heap*, on the other hand, has larger memory areas and can grow dynamically, but memory management is more complex. Especially in languages like C and C++, memory management in *heap* is done manually, which can cause memory leaks. In languages like Java and C#, memory management in *heap* is done automatically by the *garbage collector*, which prevents memory leaks but may create a cost on performance.

*Stack* is ideal especially for situations requiring fast access. For example, local variables need to be managed quickly during function calls. *Heap*, on the other hand, is used for larger and more complex data structures. For example, in an object-oriented program, objects are created on the *heap*, and the lifespan of these objects can continue throughout the runtime of the program. *Heap* is also used for dynamic data structures.

In conclusion, *Stack* and *Heap* are used for different functions, and each offers different advantages. *Stack* is ideal for fast and short-term data management, while *Heap* is used for larger and dynamic memory areas. When developing software, determining which memory structure to use is of great importance in terms of performance and memory management. The correct use of *Stack* and *Heap* ensures that the software is more efficient and sustainable.

## Exception means? Type of Exceptions?

*Exception* is an event that occurs when a program encounters an unexpected situation during its execution. That is, they are errors that prevent the program from running correctly. These errors occur at runtime of the software and usually lead to program crashes. However, when *exceptions* are handled correctly, these errors can be managed without the program crashing and it can continue to run properly.

An *exception* usually consists of two components: error type and error message. The error type indicates what kind of problem the error is, while the error message provides more information about this problem. In languages like Java, *exceptions* are managed using a special class structure. These classes are grouped according to the type of errors and contain a specific method for how to handle each type.

*Exception* types are generally examined in two main categories: *checked* and *unchecked* *exception*s.

*Checked exception*s are errors that may inevitably occur during the execution of the program and originate from external factors. The management of these types of errors is generally left to the programmer. For example, situations such as a file not being found during a file reading operation or a database connection being lost can be examples of *checked exception*s. In Java, *checked exception*s are indicated with the `throws` keyword and usually include error classes such as `IOException`, `SQLException`. The programmer is required to handle these types of errors because these errors may be inevitable.

*Unchecked exception*s, on the other hand, are exceptions caused by errors made by the programmer and are generally related to logic errors. These types of errors usually result from incorrect logic or data entry. For example, errors such as division by zero error, exceeding the boundaries of the array are *unchecked exception*s. These types of errors are generally derived from the `RuntimeException` class, and errors such as `NullPointerException`, `ArrayIndexOutOfBoundsException`, `ArithmeticException` in Java fall into this category. *Unchecked exception*s do not have to be caught mandatorily to prevent the program from running; however, managing these errors increases the stability of the program.

In Java, `try-catch` blocks are used to handle *exceptions*. When an *exception* occurs in a code block, it is placed inside a `try` block to prevent the program from crashing, and errors are caught in the `catch` block. In this way, even if the program receives an error, it can continue to run properly.

For example, the absence of a file during a file reading operation can be handled with a *checked exception*, while in case of incorrect format of data received from the user, an error can be given with an *unchecked exception*. Therefore, *exceptions* play an important role in improving the error management and user experience of the program.

In conclusion, *exceptions* are critical for providing error management in software. Although errors are inevitable, when managed correctly, the program can be ensured to run healthily.

## How to summarize ‘clean code’ as short as possible?

*Clean code* is a principle-based approach in software development, and simply put, it aims to make the code you write both functional and sustainable. The most important thing in this approach is to write code that is as understandable and organized as possible for the long-term maintenance and development of the software. When writing *clean code*, your code is expected to be in a way that not only you, but also others can easily read and understand. You should not forget that the code should be open to future changes and bug fixes. Now let's examine this in more detail.

First of all, the most basic rule of writing *clean code* is readability. A piece of code should be in a way that everyone working on that project can easily understand. For example, when naming a function, you should use meaningful names that correctly express what that function does. Let's say a function sorts a list, it is much more useful to give it an understandable name like "`sortList`" compared to meaningless names like "`doIt`". This not only correctly describes the function's function, but also makes it much easier for others to understand the code.

Another important principle is that functions should be small and focused. When writing *clean code*, each function should do only one thing, and it should focus on a single purpose while doing this. For example, it may be problematic in terms of *clean code* if a function both receives data and saves it to the database and sends an e-mail. In this case, it would be more appropriate to write two different functions; one for database operations and the other for sending e-mails. In this way, each function performs a single function, and future changes can only be made on the relevant function.

Avoiding unnecessary code repetitions is also a fundamental part of *clean code*. This is based on the DRY (*Don’t Repeat Yourself*) principle. If a piece of code is repeated in more than one place, then it would be more logical to turn this piece of code into a function and call it where necessary. This both increases the readability of the code and allows you to update all the code by making changes in only one place when any changes are needed. For example, instead of writing the same validation operations every time for the payment process, you can put this validation in a single function and use this function everywhere.

Another important issue is using comment lines, but this should be done carefully to avoid creating misunderstandings. As the understandability of the code increases, the need for comments decreases. However, comments may sometimes be needed to explain the content of complex algorithms. The thing to pay attention to here is that comments should explain why and how the code does something, not what it does. For example, explaining why an algorithm is written in this way or why a certain step is preferred makes it much easier for other developers to understand the code.

Let's take the payment process on an e-commerce site as a real-life example. Let's say that in this process, user information will be verified, payment will be made, and then an e-mail will be sent. If all these operations are done in a single function, the code becomes complex and incomprehensible. Instead, writing a function for the payment process, another function for verification, and another function for sending e-mails provides a much cleaner code structure. In this way, when you change a function, you only update that function, and other parts are not affected.

Finally, writing *clean code* is not only a technical requirement, but also very important for a cooperating team. If you are in a software development team, you need to share your code with others and ensure that they understand it. *Clean code* comes into play right here. If the code you write is clean, organized, and understandable, another developer can easily read this code and make changes on it. This increases efficiency within the team and reduces the error rate.

In summary, the aim of writing *clean code* is not only to run the code, but also to make that code easy to maintain, understandable, and sustainable in the future. Code that everyone can easily read, that uses meaningful function names, that minimizes repetitions, that avoids unnecessary complexities, and that writes meaningful comments is *clean code*. Code written in this way makes the work of both you and your team easier and allows the software to grow more efficiently.

## What is method hiding in Java?

In Java, *method hiding* is a situation created when subclasses *override* *static* methods from their superclasses by redefining them with the same name. *Static* methods are specific to the class, so they work through the class, not through the object. This can make it more difficult to understand how method hiding works. *Method hiding* should not be confused with *method overriding* because *method overriding* is only valid for *instance method*s and works at *runtime*, but *method hiding* is valid for *static methods* and the decision is made at *compile-time*.

To explain with an example, let's say you have a `Person` class and this class has a *static* method. The `Employee` class, which extends this class, also redefines the same method as *static*. The critical point here is that both methods belong to different classes. In this case, the `Employee` class "hides" the *static* method in the `Person` class.

Let's explain with a real-life example. Let's say there is a company management system, and in this system, there are employee, manager, and other personnel types. Let's assume that all personnel have a common feature, the "login" function. The `Person` class has a `login()` method, but there may be different login processes for managers and employees. If a `Manager` class or `Employee` class derives from the `Person` class and defines its own login method, this method will be hidden with *method hiding*. However, the point to be noted here is that which method will be called will be determined by the reference type. For example, a login operation performed with a `Manager` object will run the `login()` method in the `Manager` class instead of running the `login()` method in the `Person` class.

But there is a difference here: *Static* methods determine which class's method will be called at compile-time, not at runtime. This means that when a method is hidden, which method will be called is determined during compile-time, and this is based on the reference type. That is, even when an object with an `Employee` object with a reference of type `Person` is used, the method to be called will be the method belonging to the `Person` class.

For example:

* The `Person` class has a `static void login()` method.
* The `Employee` class also hides this method with the `static void login()` method.
* If an object from the `Employee` class is created with a reference of type `Person`, the method in the `Employee` class will not be called, but the *static* method in the `Person` class will be called. Therefore, the *method hiding* situation can often lead to code becoming complex, errors being overlooked, and difficulties during software maintenance.

*Method hiding* is mostly used for *static* methods, but in some cases, it can cause a complex structure. Because *static* methods are called by reference type, which can make it difficult for the programmer to guess which method will be called. For example, in software, when an `Employee` object is called with a reference of type `Person`, it may be difficult to understand which class the *static* method belongs to. Therefore, programmers need to be careful.

When developing software, *method hiding* usually arises with the need to customize *static* methods. However, when using this hiding, we must not forget that code readability and maintenance may become difficult. Because understanding which method is called can sometimes be confusing. Instead, using a more open and clear structure will be healthier in terms of code sustainability.

In summary, *method hiding* is the process of subclasses hiding the methods in their superclasses by redefining *static* methods. However, this situation is only related to the reference type, and it is decided at compile-time which method will run. This can sometimes lead to misunderstandings and errors.

## What is the difference between abstraction and polymorphism in Java?

*Abstraction* and *Polymorphism* are quite critical concepts in object-oriented languages like Java, and they ensure that software is flexible, sustainable, and understandable. These two concepts are tools that complement each other in the software development process but have different functions. Now, let's try to explain both concepts in more detail with real-life examples.

*Abstraction* is the process of hiding the complex internal structure of an object and presenting only the necessary information. Abstraction is especially used to ensure that only important and necessary information is given to the user. This concept aims to get rid of unnecessary details and present only the features or functions that the user needs. *Abstraction* is usually performed using *abstract class*es and *interface*s. In this way, an agreement is made about what an object does, but no information is given about how it does it.

To explain with a real-life example, let's look at a phone. A phone can perform many different functions: making calls, sending messages, using the internet, etc. However, when a user wants to make a call with a phone, they are not interested in technical details such as how the call is made, how the electrical circuits inside the phone work, how signals are transmitted. The user simply presses the call button and waits for the phone to make the call. Here, the internal workings of the phone are abstracted, meaning only the necessary functions are presented to the user.

*Polymorphism*, on the other hand, means that the same method can work differently on different types of objects. That is, a method shows different functions depending on the object type. *Polymorphism* makes the software more flexible and allows the same function to work differently in different objects. *Polymorphism* is usually provided using *method overriding* and *method overloading*. With *method overriding*, subclasses can redefine methods inherited from the superclass according to their own needs, while with *method overloading*, methods with the same name can be called with different parameters.

Let's explain with an example: Suppose you are managing a zoo and there are different animal types here: Lion, Tiger, Bear, etc. These animals are all derived from the `Animal` class, and each has a `makeSound()` method. However, the sound each animal makes is different: lion roars, tiger growls, and bear growls. Here, the `makeSound()` method works differently for each animal type using *polymorphism*. That is, each animal type implements its own `makeSound()` method in a way specific to itself. The important point here is that the `makeSound()` method makes different sounds in different animal types. This is the basic purpose of *polymorphism*: The same method can work differently in different objects.

Differences:

*Abstraction* hides the internal workings of an object and presents only the necessary information to the user. This hides complexity and allows the user to focus only on what needs to be done. *Polymorphism*, on the other hand, allows the same method to work in different forms on different objects. This increases the flexibility of the software and makes it possible to use the same function differently in different objects.

*Abstraction* is mostly used in the design phase and helps to determine the basic structure of a class. *Polymorphism*, on the other hand, mostly takes place at runtime and allows the same method to be run for different objects.

*Abstraction* is usually performed using *abstract classes* or *interface*s. This shows only the necessary features of objects. *Polymorphism* is provided by *method overriding* and *method overloading* techniques.

Details in *Abstraction* abstract the behaviors that the object presents to the outside. *Polymorphism*, on the other hand, allows a method to behave differently in different objects.

Real-Life Examples: If we give the phone example we mentioned before, the phone is an example of *abstraction*. The internal structure of the phone is abstracted to the user and only the necessary functions are given. Functions such as making calls, sending messages, taking photos are presented to the user only as an interface. However, the user does not need to know how the circuits inside the phone work, how the signal is transmitted.

Another example might be company management. Let's say there are different positions in a company: Manager, Employee, Worker. Let them all be derived from the `Person` class and each has a `work()` method. However, the Manager method, unlike the Employee method, may include more strategic decision-making and management-related operations. Here, the `work()` method works differently in different positions thanks to *polymorphism*.

In conclusion, *Abstraction* and *Polymorphism* are complementary concepts that serve different purposes. *Abstraction* makes the software simpler and more understandable, while *Polymorphism* provides flexibility and expandability. In a good software design, the effective use of these two concepts allows for writing sustainable and maintenance-friendly code.

